4 сервиса:
	postgres
	kafka (broker, zookeeper)
	server_api
	worker

Pipelines:
	- Пополнение и снятие средств:
		- server_api принимает запросы от клиентов и сразу отправляет все запросы в kafka.
		- worker принимает сообщения от kafka и общается с postgres. 
		- После каждой успешной транзакции worker уведомляет kafka, что сообщение прочитано.

	- Узнать баланс:
		- server_api читает напрямую из postgres акутальный баланс.

Возможные варианты развития событий:
	- всё работает как надо.
	- падает worker:
		- все запросы будут храниться в kafka и при повторном запуске worker'a
		  он начнёт в порядке очереди выполнять транзакции для каждого пользователя.
		- баланс всё ещё можно будет узнать.
	- падает server_api:
		- пользователи в это время не смогут менять и узнавать свой баланс, но 
		  worker продолжит свою работу и будет в порядке очереди изменять баланс пользователей.
    - падает worker и server_api:
    	- все транзакции замораживаются и пользователи не могут запрашивать никакие транзакции.
    	  При восстановлении работы worker:
    	  	- все замороженные транзакции будут выполнены.
    	  При восстановлении работы server_api:
    	    - пользователи смогу дальше накапливать свои транзакции.
    		- но узнать баланс можно будет в любое время.
    - падает kafka:
    	- считаем, что kafka упасть не может, у нас кластер с репликами
    - падает postgres:
    	- по хорошему нужно тоже делать кластер, но считаем, что это невозможно 
    - когда большая очередь из транзакций:
    	- пользователь будет получать не совсем акутальный баланс, но будем считать это фичей, 
    	  так как ему не придётся ждать окончания всех запрошенных им транзакций.
    	  Чтобы узнать актуальный баланс, ему нужно будет запросить его после всех выполненых транзакций.

Нужно доработать:
	- добавить блокирующий get запрос на получение актуального баланса после всех транзакций.
	- обернуть всё в docker-compose.yml
	- написать тесты + автотесты ci/cd gitlab
	- документацию к коду



